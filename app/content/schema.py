"""Schema definitions for canonical curriculum content."""

from __future__ import annotations

from typing import Literal

from pydantic import BaseModel, Field


DifficultyLevel = Literal["introductory", "intermediate", "advanced", "challenge"]
ProblemType = Literal["conceptual", "derivation", "numerical", "coding", "analysis"]
BloomLevel = Literal[
    "remember",
    "understand",
    "apply",
    "analyze",
    "evaluate",
    "create",
]


class ContentSection(BaseModel):
    """Named section of instructional content."""

    id: str = Field(..., description="Stable identifier for the section.")
    title: str = Field(..., description="Heading for the section.")
    body: str = Field(..., description="Multi-paragraph markdown content.")


class LearningObjective(BaseModel):
    """Formal learning objective scoped to a concept."""

    id: str = Field(..., description="Stable identifier for the learning objective.")
    concept_id: str = Field(..., description="Concept the learning objective belongs to.")
    bloom: BloomLevel = Field(..., description="Bloom's taxonomy level emphasised.")
    difficulty: DifficultyLevel = Field(..., description="Relative difficulty for sequencing.")
    statement: str = Field(..., description="Canonical description of the learning objective.")
    assessment_methods: list[str] = Field(
        default_factory=list,
        description="Assessment formats that can be used to validate mastery.",
    )
    prerequisites: list[str] = Field(
        default_factory=list,
        description="Prerequisite learning objective identifiers.",
    )


class CanonicalFact(BaseModel):
    """Canonical fact or derivation that the tutor may rely on."""

    id: str = Field(..., description="Stable identifier for the fact.")
    concept_id: str = Field(..., description="Concept the fact belongs to.")
    title: str = Field(..., description="Short title for referencing the fact.")
    statement: str = Field(..., description="Precise statement of the fact.")
    derivation: str = Field(..., description="Outline or full derivation supporting the fact.")
    references: list[str] = Field(
        default_factory=list, description="Supporting references or source notes."
    )
    related_objectives: list[str] = Field(
        default_factory=list, description="Learning objective identifiers covered by the fact."
    )
    pitfalls: list[str] = Field(
        default_factory=list,
        description="Common misconceptions to surface during tutoring.",
    )


class WorkedExample(BaseModel):
    """Worked example that scaffolds a derivation or application."""

    id: str = Field(..., description="Stable identifier for the worked example.")
    concept_id: str = Field(..., description="Concept the example reinforces.")
    title: str = Field(..., description="Headline for the worked example.")
    narrative: str = Field(..., description="Context or story that frames the example.")
    steps: list[str] = Field(..., description="Ordered list of steps in the worked solution.")
    takeaways: list[str] = Field(
        default_factory=list, description="Key insights the learner should retain."
    )


class ProblemInstance(BaseModel):
    """Concrete problem instance emitted by a template."""

    template_id: str = Field(..., description="Identifier of the originating template.")
    variant_id: str = Field(..., description="Identifier for the deterministic variant.")
    prompt: str = Field(..., description="The full prompt shown to the learner.")
    solution: str = Field(..., description="Canonical worked solution for verification.")
    answer: str | None = Field(
        default=None, description="Short-form answer (if applicable for grading)."
    )
    rubric: str | None = Field(
        default=None, description="Free-text rubric or grading guidance."
    )
    unit_test_stub: str | None = Field(
        default=None,
        description="Optional Python unit test scaffold for coding labs.",
    )


class ProblemTemplateMetadata(BaseModel):
    """Metadata describing a deterministic problem template."""

    id: str = Field(..., description="Stable identifier for the template.")
    concept_id: str = Field(..., description="Concept the template supports.")
    title: str = Field(..., description="Human-readable template name.")
    description: str = Field(..., description="Summary of what the template exercises.")
    difficulty: DifficultyLevel = Field(..., description="Relative difficulty of the template.")
    problem_type: ProblemType = Field(..., description="Type of activity generated by the template.")
    canonical_fact_ids: list[str] = Field(
        default_factory=list, description="Canonical facts leveraged by the template."
    )
    learning_objective_ids: list[str] = Field(
        default_factory=list,
        description="Learning objectives that the template measures or reinforces.",
    )
    variant_ids: list[str] = Field(
        default_factory=list,
        description="Deterministic variant identifiers available for the template.",
    )
    tags: list[str] = Field(default_factory=list, description="Additional curation tags.")


class ProblemTemplate(BaseModel):
    """Template containing metadata and deterministic variants."""

    metadata: ProblemTemplateMetadata = Field(..., description="Template metadata block.")
    variants: dict[str, ProblemInstance] = Field(
        default_factory=dict,
        description="Mapping of variant identifier to deterministic instance.",
    )

    def instantiate(self, variant_id: str) -> ProblemInstance:
        """Return the deterministic variant associated with the identifier."""

        try:
            return self.variants[variant_id].model_copy(deep=True)
        except KeyError as exc:  # pragma: no cover - defensive branch
            raise KeyError(
                f"Variant '{variant_id}' not defined for template '{self.metadata.id}'."
            ) from exc


class Concept(BaseModel):
    """High-level concept description used by tutors and planners."""

    id: str = Field(..., description="Stable identifier for the concept.")
    slug: str = Field(..., description="Slug suitable for URLs.")
    title: str = Field(..., description="Human-readable name for the concept.")
    summary: str = Field(..., description="Brief overview of the concept.")
    prerequisites: list[str] = Field(
        default_factory=list, description="Other concept identifiers that are prerequisites."
    )
    primary_objectives: list[str] = Field(
        default_factory=list,
        description="Learning objective identifiers that define mastery for the concept.",
    )
    canonical_fact_ids: list[str] = Field(
        default_factory=list, description="Canonical fact identifiers underpinning the concept."
    )
    worked_example_ids: list[str] = Field(
        default_factory=list, description="Worked example identifiers attached to the concept."
    )
    problem_template_ids: list[str] = Field(
        default_factory=list,
        description="Problem template identifiers available for practice.",
    )
    sections: list[ContentSection] = Field(
        default_factory=list,
        description="Rich content sections that make up the instructional module.",
    )


class ConceptDetail(BaseModel):
    """Fully expanded concept representation used by the API."""

    concept: Concept = Field(..., description="Concept metadata and instructional sections.")
    learning_objectives: list[LearningObjective] = Field(
        default_factory=list,
        description="Learning objectives associated with the concept.",
    )
    canonical_facts: list[CanonicalFact] = Field(
        default_factory=list, description="Canonical facts grounding the concept."
    )
    worked_examples: list[WorkedExample] = Field(
        default_factory=list, description="Worked examples learners can study."
    )
    problem_templates: list[ProblemTemplate] = Field(
        default_factory=list,
        description="Problem templates available for practice and assessment.",
    )
